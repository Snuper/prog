<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//RU">
<HTML><HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=Windows-1251">
<script src="..\Scripts\main.js"></script>
</HEAD> 
<BODY BACKGROUND="..\pictures\bgpicture.gif" BGCOLOR="white" TEXT="gray" LINK="blue" VLINK="magenta" ALINK="cyan">
<Script>
<!-- hide
changeh3();
 hide -->
</script>
<center>ћетод пр€мого сли€ни€</center></H3>
<Script>
<!-- hide
changep();
 hide -->
</script>
ќбща€ иде€:<BR>
ѕусть размер списка S равен 2^k.
ѕоследовательность S разделим на на 2 списка a и b, затем 
списки a и b сливаютс€ в одну очередь с образованием 
двойных серий, т.е. длиной в 2 элемента. ѕричем эти 
двойные серии записываютс€ поочередно в очередь c0 и c1, 
затем очередь c0 переписываетс€ в список a, 
c1 - в список b. —нова сливаем списки a и b, но с 
образованием четвертных серий, затем с образованием 
8-,16-, и т.д. серий, пока не получим одну большую серию 
длиной во весь список, т.е. отсортированый список.
≈сли S не равна 2^k, то нужно учесть в алгоритме, что 
некоторые серии могут быть короче, чем ожидаетс€.
</P>
<Script>
<!-- hide
changep();
 hide -->
</script>
јлгоритм расщеплени€ списка на a и b.
 роме расщеплени€ будем подсчитывать количество 
элементов в списке.
</P>
<Script>
<!-- hide
changepre();
 hide -->
</script>
a:=S;
b:=S^.next;
n:=1;
k:=a;
L:=b;
DO(L&lt;0)
     n:=n+1;
     k^.next:=L^.next;
     k:=L;
     L:=L^.next;
OD
</Pre>
<Script>
<!-- hide
changep();
 hide -->
</script>
јлгоритм MergeSort(S)<BR>
n    - количество элементов<BR>
a,b  - рабочие списки<BR>
c    - массив очередей<BR>
p    - предполагаемый размер серий<BR>
q,r  - насто€щий размер серий в списках a,b<BR>
m    - общее количество элементов в обоих списках<BR>
i    - номер активной очереди<BR>
</P>
<Script>
<!-- hide
changepre();
 hide -->
</script>
<–ащепление(S,a,b,n)>
p:=1;
DO(p&lt;n)
      <инициализаци€ очередей c[0] и c[1]>
      i:=0; m:=n;
      DO(m>0)
        {определ€ем фактический размер серий}
        IF (m>p) q:=p ELSE q:=m; FI
        m:=m-q;
        IF (m>p)  r:=p ELSE r:=m; FI
        m:=m-r;
        <—ли€ние q - серии из списка a 
         с r - серией из списка b;результат в c[i]>
        i:=1-i;
      OD
      p:=2*p;
      a:=c[0].head;
      b:=c[1].head;
OD
c[0].tail^.next:=nil;
S:=c[0].head;
</Pre>
<Script>
<!-- hide
changep();
 hide -->
</script>
“рудоемкость метода:<BR>
Ќа каждой итерации происходит n сравнений, 
а пересылок M&lt;C. 
“аким образом
</P>
<Script>
<!-- hide
changepre();
 hide -->
</script> 
C&lt;n[logn]
M=nlogn+n
T=O(nlogn)
</Pre>
<Script>
<!-- hide
changep();
 hide -->
</script>
ќсобенности метода:<BR>
—ортировка устойчива. ћетодможет быть реализован 
и дл€ массивов, но в таком случае потребуетс€ еще 
один массив равный исходному.
</P>
</BODY>
</HTML>