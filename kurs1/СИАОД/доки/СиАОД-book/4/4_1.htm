<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//RU">
<HTML><HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=Windows-1251">
<script src="..\Scripts\main.js"></script>
</HEAD> 
<BODY BACKGROUND="..\pictures\bgpicture.gif" BGCOLOR="white" TEXT="gray" LINK="blue" VLINK="magenta" ALINK="cyan">
<Script>
<!-- hide
changeh3();
 hide -->
</script>
<center>Постановка задачи</center></H3>
<Script>
<!-- hide
changep();
 hide -->
</script>
Ранее рассмотренные алгоритмы организовывали данные с целью 
быстрого поиска, причем всегда множеству ключей 
сопоставлялось множество адрессов памяти, т.е. находили 
отображение H: K->A (A=H(K)). Раньше всегда ключу жестко 
соответствовал адресс памяти, а теперь рассмотрим задачу 
быстрого поиска, но теперь <Script>
<!-- hide
changepre();
 hide -->
</script>[[K]]>>[[A]].</PRE>
<Script>
<!-- hide
changep();
 hide -->
</script>
Хеш-функцией Y = H(X) называется такая функция, определенная 
на множестве X, для которой [[X]]>>[[Y]], т.е. эта функция 
принадлежит классу множество значений в одно и допускает, 
чтобы нескольким значениям разным X соответствовало одно 
значение Y.
</P>
<Script>
<!-- hide
changep();
 hide -->
</script>
Хеширование - эффективный способ организации данных с целью 
быстрого поиска по ключу, при этом над ключом производятся 
некоторые арифметические действия, получается, что хеш-адрес 
h=H(K) вычисляется с помощью хеш-функции, которая указывает 
адрес страницы, где хранится ключ K и связанная 
с ним информация.
</P>
<Script>
<!-- hide
changep();
 hide -->
</script>
В связи со свойствами функции найдутся такие ключи 
<Script>
<!-- hide
changepre();
 hide -->
</script>Ki&lt;&gt;Kj =&gt; H(Ki)=H(Kj),</PRE><Script>
<!-- hide
changep();
 hide -->
</script> эта ситуация называется 
коллизией.  
</P>
<Script>
<!-- hide
changep();
 hide -->
</script>
Основная идея поиска с использованием хеширования<BR>
В самом прстом случае данные могут быть организованы 
в виде массива, тогда вместо адрессов используются номера
в массиае, тогда хеш-функция ставит в соответствие ключу 
номер массива
</P>
<Script>
<!-- hide
changep();
 hide -->
</script>
Идея:<BR>
<OL>
<LI><Script>
<!-- hide
changep();
 hide -->
</script>Вычислить значение хеш-функции по известному ключу
<LI><Script>
<!-- hide
changep();
 hide -->
</script>Проверить действительно ли в таблице с вычисленным 
номером находится тот самый ключ, т.е. надо проверить 
<Script>
<!-- hide
changepre();
 hide -->
</script>T[H(K)].data=K (T[H(K)=K]),</PRE><Script>
<!-- hide
changep();
 hide -->
</script> если равенство не верно, 
то возникла коллизия, надо применить один из способов 
ее разрешения.
</OL>
</P>
<Script>
<!-- hide
changep();
 hide -->
</script>
При хешировании возникают две проблеммы:
<OL>
<LI><Script>
<!-- hide
changep();
 hide -->
</script>Выбор вида функции.
<LI><Script>
<!-- hide
changep();
 hide -->
</script>Выбор способа разрешения коллизий.
</OL>
</P>
<P>
<OL>
<LI><Script>
<!-- hide
changep();
 hide -->
</script>Вычисление должно быть как можно быстрее.
<LI><Script>
<!-- hide
changep();
 hide -->
</script>Функция должна давать минимальное количество коллизий, 
т.е. более равномерно распределены ключи по хеш-таблице.
</OL>
</P>
<Script>
<!-- hide
changep();
 hide -->
</script>
Для разрешения коллизий используется:
Метод указаний альтернативного местоположения ключа 
в таблице.
</p>
</BODY>
</HTML>